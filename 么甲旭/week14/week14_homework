import re
from collections import defaultdict


def get_stats(vocab):
    """计算所有相邻符号对的频率"""
    pairs = defaultdict(int)
    for word, freq in vocab.items():
        symbols = word.split()
        for i in range(len(symbols) - 1):
            pairs[symbols[i], symbols[i + 1]] += freq
    return pairs


def merge_vocab(pair, v_in):
    """合并最频繁的符号对并更新词汇表"""
    v_out = {}
    bigram = re.escape(' '.join(pair))
    p = re.compile(r'(?<!\S)' + bigram + r'(?!\S)')
    for word in v_in:
        w_out = p.sub(''.join(pair), word)
        v_out[w_out] = v_in[word]
    return v_out


def bpe_train(vocab, num_merges):
    """执行BPE训练，返回合并规则和词汇表"""
    # 初始化：每个字符作为一个独立符号
    bpe_codes = {}
    for i in range(num_merges):
        pairs = get_stats(vocab)
        if not pairs:
            break
        # 选择频率最高的符号对
        best = max(pairs, key=pairs.get)
        # 记录合并规则
        bpe_codes[best] = i
        # 合并符号对并更新词汇表
        vocab = merge_vocab(best, vocab)
    return bpe_codes, vocab


def encode(text, bpe_codes):
    """使用BPE编码文本"""
    # 初始分词：按字符分割
    chars = list(text)
    # 应用BPE合并规则
    while True:
        pairs = [(i, (chars[i], chars[i + 1])) for i in range(len(chars) - 1)]
        # 查找已学习的合并规则中最优先的符号对
        candidates = [(bpe_codes.get(pair, float('inf')), i, pair) for i, pair in pairs if pair in bpe_codes]
        if not candidates:
            break
        # 选择最优先的符号对进行合并
        _, min_idx, best_pair = min(candidates)
        # 执行合并
        new_chars = []
        i = 0
        while i < len(chars):
            if i == min_idx:
                new_chars.append(''.join(best_pair))
                i += 2
            else:
                new_chars.append(chars[i])
                i += 1
        chars = new_chars
    return chars


# 示例使用
if __name__ == "__main__":
    # 示例训练数据：统计词频
    corpus = "low low low new newer newest widest"
    vocab = defaultdict(int)
    for word in corpus.split():
        # 用空格分隔字符，并添加词尾标记
        vocab[' '.join(list(word)) + ' </w>'] += 1

    # 训练BPE，执行10次合并
    bpe_codes, merged_vocab = bpe_train(vocab, num_merges=10)

    # 打印学习到的合并规则
    print("BPE合并规则:")
    for pair, rank in bpe_codes.items():
        print(f"Rank {rank}: {pair[0]} + {pair[1]} -> {''.join(pair)}")

    # 编码测试文本
    test_text = "lowest"
    encoded = encode(test_text + ' </w>', bpe_codes)
    print(f"\n编码结果: {encoded}")
